const std = @import("std");
const Lexer = @import("Lexer.zig");
const Parser = @import("Parser.zig");
const CodeGen = @import("CodeGen.zig");

pub const CompileError = error{
    LexError,
    ParseError,
    CodeGenError,
    InvalidSyntax,
    UndefinedVariable,
    UndefinedFunction,
    TypeMismatch,
    OutOfMemory,
};

pub const Compiler = struct {
    allocator: std.mem.Allocator,
    source: []const u8,
    error_messages: std.ArrayList([]const u8),

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, source: []const u8) Self {
        return .{
            .allocator = allocator,
            .source = source,
            .error_messages = std.ArrayList([]const u8){},
        };
    }

    pub fn deinit(self: *Self) void {
        for (self.error_messages.items) |msg| {
            self.allocator.free(msg);
        }
        self.error_messages.deinit(self.allocator);
    }

    /// Compile HolyC source code to BPF bytecode
    pub fn compile(self: *Self) ![]const u8 {
        // Lexical analysis
        var lexer = Lexer.Lexer.init(self.allocator, self.source);
        defer lexer.deinit();

        lexer.scanTokens() catch |err| {
            try self.addError("Lexical analysis failed");
            return err;
        };

        // Syntax analysis
        var parser = Parser.Parser.init(self.allocator, lexer.tokens.items);
        const ast = parser.parse() catch |err| {
            try self.addError("Syntax analysis failed");
            return err;
        };
        defer ast.deinit();

        // Code generation
        var codegen = CodeGen.CodeGen.init(self.allocator);
        defer codegen.deinit();

        codegen.generate(ast) catch |err| {
            try self.addError("Code generation failed");
            return err;
        };

        // Validate generated bytecode
        if (!codegen.validateInstructions()) {
            try self.addError("Generated invalid BPF instructions");
            return error.CodeGenError;
        }

        // Convert instructions to bytecode
        var output = std.ArrayList(u8){};
        errdefer output.deinit(self.allocator);

        for (codegen.instructions.items) |instruction| {
            const bytes = std.mem.asBytes(&instruction);
            try output.appendSlice(self.allocator, bytes);
        }

        return output.toOwnedSlice(self.allocator);
    }

    fn addError(self: *Self, message: []const u8) !void {
        const owned_msg = try self.allocator.dupe(u8, message);
        try self.error_messages.append(self.allocator, owned_msg);
    }

    /// Get compilation error messages
    pub fn getErrors(self: *Self) []const []const u8 {
        return self.error_messages.items;
    }
};