use std::fs;
use std::path::Path;
use thiserror::Error;

use crate::pible::{lexer::Lexer, parser::Parser, codegen::CodeGen, solana_bpf::SolanaBpf, bpf_vm::BpfVm};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CompileTarget {
    LinuxBpf,
    SolanaBpf,
    BpfVm,
}

#[derive(Debug, Clone)]
pub struct CompileOptions<'a> {
    pub target: CompileTarget,
    pub generate_idl: bool,
    pub enable_vm_testing: bool,
    pub solana_program_id: Option<[u8; 32]>,
    pub output_directory: Option<&'a str>,
}

impl<'a> Default for CompileOptions<'a> {
    fn default() -> Self {
        Self {
            target: CompileTarget::LinuxBpf,
            generate_idl: false,
            enable_vm_testing: false,
            solana_program_id: None,
            output_directory: None,
        }
    }
}

#[derive(Error, Debug)]
pub enum CompileError {
    #[error("Lexical analysis failed: {0}")]
    LexError(String),
    #[error("Syntax analysis failed: {0}")]
    ParseError(String),
    #[error("Code generation failed: {0}")]
    CodeGenError(String),
    #[error("Invalid syntax: {0}")]
    InvalidSyntax(String),
    #[error("Undefined variable: {0}")]
    UndefinedVariable(String),
    #[error("Undefined function: {0}")]
    UndefinedFunction(String),
    #[error("Type mismatch: {0}")]
    TypeMismatch(String),
    #[error("Unsupported target: {0:?}")]
    UnsupportedTarget(CompileTarget),
    #[error("IDL generation failed: {0}")]
    IdlGenerationError(String),
    #[error("VM execution failed: {0}")]
    VmExecutionError(String),
    #[error("File I/O error: {0}")]
    IoError(#[from] std::io::Error),
}

pub struct Compiler {
    error_messages: Vec<String>,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            error_messages: Vec::new(),
        }
    }

    pub fn compile_file(&self, input_path: &str, options: &CompileOptions) -> Result<(), CompileError> {
        let source = fs::read_to_string(input_path)
            .map_err(|e| CompileError::IoError(e))?;
        
        let output = self.compile(&source, options)?;
        
        // Determine output path
        let output_path = self.determine_output_path(input_path, options);
        
        // Write compiled output
        fs::write(&output_path, output)
            .map_err(|e| CompileError::IoError(e))?;
        
        println!("Compiled successfully: {} -> {}", input_path, output_path);
        
        // Generate IDL if requested
        if options.generate_idl && options.target == CompileTarget::SolanaBpf {
            let idl_path = output_path.replace(".bpf", ".json");
            let idl_json = self.generate_idl_json(&source, options)?;
            fs::write(&idl_path, idl_json)
                .map_err(|e| CompileError::IoError(e))?;
            println!("IDL generated: {}", idl_path);
        }
        
        Ok(())
    }

    pub fn compile(&self, source: &str, options: &CompileOptions) -> Result<Vec<u8>, CompileError> {
        // Lexical analysis
        let mut lexer = Lexer::new(source);
        let tokens = lexer.scan_tokens()
            .map_err(|e| CompileError::LexError(format!("{:?}", e)))?;

        // Syntax analysis
        let mut parser = Parser::new(tokens);
        let ast = parser.parse()
            .map_err(|e| CompileError::ParseError(format!("{:?}", e)))?;

        // Code generation based on target
        match options.target {
            CompileTarget::LinuxBpf => self.compile_linux_bpf(&ast, options),
            CompileTarget::SolanaBpf => self.compile_solana_bpf(&ast, options),
            CompileTarget::BpfVm => self.compile_for_vm(&ast, options),
        }
    }

    fn compile_linux_bpf(&self, ast: &crate::pible::parser::Node, _options: &CompileOptions) -> Result<Vec<u8>, CompileError> {
        let mut codegen = CodeGen::new();
        let instructions = codegen.generate(ast)
            .map_err(|e| CompileError::CodeGenError(format!("{:?}", e)))?;

        // Validate generated bytecode
        if !codegen.validate_instructions(&instructions) {
            return Err(CompileError::CodeGenError("Generated invalid BPF instructions".to_string()));
        }

        Ok(self.instructions_to_bytes(&instructions))
    }

    fn compile_solana_bpf(&self, ast: &crate::pible::parser::Node, _options: &CompileOptions) -> Result<Vec<u8>, CompileError> {
        let mut codegen = CodeGen::new();
        
        // Generate regular code first
        let instructions = codegen.generate(ast)
            .map_err(|e| CompileError::CodeGenError(format!("{:?}", e)))?;

        // Create solana codegen and validate
        let solana_codegen = SolanaBpf::new(&mut codegen);
        
        // Generate Solana-specific entrypoint
        // solana_codegen.generate_entrypoint("entrypoint")
        //     .map_err(|e| CompileError::CodeGenError(format!("{:?}", e)))?;

        // Validate Solana BPF constraints
        if !solana_codegen.validate_solana_program(&instructions) {
            return Err(CompileError::CodeGenError("Generated program violates Solana BPF constraints".to_string()));
        }

        Ok(self.instructions_to_bytes(&instructions))
    }

    fn compile_for_vm(&self, ast: &crate::pible::parser::Node, options: &CompileOptions) -> Result<Vec<u8>, CompileError> {
        let mut codegen = CodeGen::new();
        let instructions = codegen.generate(ast)
            .map_err(|e| CompileError::CodeGenError(format!("{:?}", e)))?;

        // Test execution in VM if enabled
        if options.enable_vm_testing {
            self.test_in_vm(&instructions)?;
        }

        Ok(self.instructions_to_bytes(&instructions))
    }

    fn test_in_vm(&self, instructions: &[crate::pible::codegen::BpfInstruction]) -> Result<(), CompileError> {
        let mut vm = BpfVm::new(instructions);
        let result = vm.execute()
            .map_err(|e| CompileError::VmExecutionError(format!("{:?}", e)))?;

        println!("VM test completed: exit_code={}, compute_units={}", result.exit_code, result.compute_units);
        Ok(())
    }

    fn generate_idl_json(&self, source: &str, _options: &CompileOptions) -> Result<String, CompileError> {
        // For now, generate a basic IDL structure
        // In a full implementation, this would extract from the AST
        let idl = serde_json::json!({
            "version": "0.1.0",
            "name": "holyc_program",
            "instructions": [
                {
                    "name": "entrypoint",
                    "args": [
                        {
                            "name": "input",
                            "type": "bytes"
                        }
                    ],
                    "accounts": []
                }
            ],
            "accounts": [],
            "types": [],
            "events": [],
            "errors": [],
            "metadata": {
                "description": "Divine HolyC program compiled to Solana BPF",
                "source": source.len()
            }
        });

        serde_json::to_string_pretty(&idl)
            .map_err(|e| CompileError::IdlGenerationError(e.to_string()))
    }

    fn instructions_to_bytes(&self, instructions: &[crate::pible::codegen::BpfInstruction]) -> Vec<u8> {
        let mut output = Vec::new();
        for instruction in instructions {
            output.extend_from_slice(&instruction.to_bytes());
        }
        output
    }

    fn determine_output_path(&self, input_path: &str, options: &CompileOptions) -> String {
        let input_path = Path::new(input_path);
        let file_stem = input_path.file_stem().unwrap().to_str().unwrap();
        let dir = if let Some(output_dir) = options.output_directory {
            Path::new(output_dir)
        } else {
            input_path.parent().unwrap_or(Path::new("."))
        };
        
        dir.join(format!("{}.bpf", file_stem)).to_str().unwrap().to_string()
    }

    pub fn get_errors(&self) -> &[String] {
        &self.error_messages
    }
}